include.censnobs = TRUE, include.wald = TRUE, ...) {
e <- extract(model$zelig.out$z.out[[1]], include.aic = include.aic,
include.bic = include.bic, include.loglik = include.loglik,
include.deviance = include.deviance, include.nobs = include.nobs,
include.censnobs = include.censnobs, include.wald = include.wald, ...)
return(e)
}
setMethod("extract", signature = className("Zelig", "Zelig-logit-gee"),
definition = extract.ZeligGee)
extract(logitgee.1)
extract.ZeligGee <- function(model, include.aic = TRUE, include.bic = TRUE,
include.loglik = TRUE, include.deviance = TRUE, include.nobs = FALSE,
include.censnobs = TRUE, include.wald = TRUE) {
e <- extract(model$zelig.out$z.out[[1]], include.aic = include.aic,
include.bic = include.bic, include.loglik = include.loglik,
include.deviance = include.deviance, include.nobs = include.nobs,
include.censnobs = include.censnobs, include.wald = include.wald, ...)
return(e)
}
setMethod("extract", signature = className("Zelig", "Zelig-logit-gee"),
definition = extract.ZeligGee)
extract(logitgee.1)
library(Zelig)
data(turnout)
turnout$cluster <- rep(c(1:200), 10)
sorted.turnout <- turnout[order(turnout$cluster), ]
z.out1 <- zelig(vote ~ race + educate, model = "logit.gee",
id = "cluster", data = sorted.turnout)
library(texreg)
texreg(z.out1)
extract.ZeligGee <- function(model, include.aic = TRUE, include.bic = TRUE,
include.loglik = TRUE, include.deviance = TRUE, include.nobs = FALSE,
include.censnobs = TRUE, include.wald = TRUE) {
e <- extract(model$zelig.out$z.out[[1]], include.aic = include.aic,
include.bic = include.bic, include.loglik = include.loglik,
include.deviance = include.deviance, include.nobs = include.nobs,
include.censnobs = include.censnobs, include.wald = include.wald, ...)
return(e)
}
setMethod("extract", signature = className("Zelig", "geeglm"),
definition = extract.ZeligGee)
screenreg(model)
screenreg(logitgee.1)
stargazer(cox1.tt, cox2, cox.L, clogit.1, cox2.ag, logitgee.1.l,
type = "latex", # change to "latex"/"text" when nedded
covariate.labels=c(
"Manufacture Output$_{tt}$",
"Agricultural Output$_{tt}$",
"Manufacture Output  \\emph{(ln)}",
"Agricultural Output  \\emph{(ln)}",
"Manufacture Output$_{t-1}$  \\emph{(ln)}",
"Agricultural Output$_{t-1}$  \\emph{(ln)}",
"Total Population  \\emph{(ln)}",
"Urban Population  \\emph{(ln)}"
),
column.labels = c("Cox PH", "Conditional Logit", "Andersen-Gill"),
column.separate = c(3, 1, 1),
model.names = F,
dep.var.labels=c("Income Taxation", "", "Taxation and Democracy"),
dep.var.labels.include = T, # edit this one to get rid of the annoying model titles
add.lines = list(
c("FE", "No", "No", "No", "Yes", "No"),
c("Transformation", "Time", "Logged", "Lagged", "Logged", "Logged")
),
label = "results:1",
notes = "Robust Std. Errors in Parentheses",
title = "Structural Origins of Income Taxation",
font.size = "tiny",
table.placement = "h",
notes.align = "c",
keep.stat = c("n","ll", "chi2"),
style = "apsr")
install.packages("knitr")
install.packages("gridextra")
install.packages("gridExtra")
cat("\014")
rm(list=ls())
setwd("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption")
# Load Datasets
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/incometax_data.RData") # Load data
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/cox.RData") # Cox
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/L_cox.RData") # Lagged Data for Cox
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/logitgee.RData") # Logit GEE
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/ag_data.RData") # For Multiple Non Competing Hazard Ratios
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/l_clogit.RData") # Lagged CONSTANT AGR MANUFACT for clogit  (fixed effects)
# Loading/Installing Library
# install.packages("survival")
library(survival) # Cox Models
library(survival) # Cox Models
# DO NOT TOUCH
# Model with time-transformed variables
cox1.tt = coxph(Surv(year, incometax.s) ~ tt(constmanufact) + tt(constagricult) + cluster(country),
data=cox, x=T
)
# DO NOT TOUCH
# WORKING MODEL
cox2 = coxph(Surv(year, incometax.s) ~ log(constmanufact) + log(constagricult) + log(totpop) + cluster(country),
data=cox
)
# DO NOT TOUCH
# LAGGED MODEL
cox.L = coxph(Surv(year, incometax.s) ~ log(constmanufact.L) + log(constagricult.L) + log(totpop) + cluster(country),
data=L.cox)
library(geepack) # install.packages("geepack")
## logit GEE
logitgee.1 = geeglm(incometax.d ~ log(constmanufact) + log(constagricult) + log(totpop),
family = binomial,
id = country,
corstr = "exchangeable",
data = logitgee)
citation(geepack)
library(geepack) # install.packages("geepack")
citation(geepack)
##################################################
# Start Fresh
cat("\014")
rm(list=ls())
setwd("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption")
# Load Datasets
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/incometax_data.RData") # Load data
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/cox.RData") # Cox
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/L_cox.RData") # Lagged Data for Cox
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/logitgee.RData") # Logit GEE
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/ag_data.RData") # For Multiple Non Competing Hazard Ratios
load("/Users/hectorbahamonde/RU/Dissertation/Papers/IncomeTaxAdoption/l_clogit.RData") # Lagged CONSTANT AGR MANUFACT for clogit  (fixed effects)
# Loading/Installing Library
# install.packages("survival")
library(survival) # Cox Models
# DO NOT TOUCH
# Model with time-transformed variables
cox1.tt = coxph(Surv(year, incometax.s) ~ tt(constmanufact) + tt(constagricult) + cluster(country),
data=cox, x=T
)
# DO NOT TOUCH
# WORKING MODEL
cox2 = coxph(Surv(year, incometax.s) ~ log(constmanufact) + log(constagricult) + log(totpop) + cluster(country),
data=cox
)
# DO NOT TOUCH
# LAGGED MODEL
cox.L = coxph(Surv(year, incometax.s) ~ log(constmanufact.L) + log(constagricult.L) + log(totpop) + cluster(country),
data=L.cox)
library(geepack) # install.packages("geepack")
## logit GEE
logitgee.1 = geeglm(incometax.d ~ log(constmanufact) + log(constagricult) + log(totpop),
family = binomial,
id = country,
corstr = "exchangeable",
data = logitgee)
## ---- texreg-extractor-geeglm ----
extract.geepack <- function(model) {
s <- summary(model)
names <- rownames(s$coef)
co <- s$coef[, 1]
se <- s$coef[, 2]
pval <- s$coef[, 4]
n <- nrow(model.frame(model))
nclust <- length(s$geese$clusz)
gof = c(n, nclust)
gof.names = c("Num. obs.", "Num. clust.")
tr <- createTexreg(
coef.names = names,
coef = co,
se = se,
pvalues = pval,
gof.names = gof.names,
gof = gof,
gof.decimal = rep(FALSE, length(gof))
)
return(tr)
}
logitgee.1.d = extract.geepack(logitgee.1)
# DONT TOUCH
# Recurrent Events: Income Tax AND Democracy
# WORKING MODEL
cox2.ag = coxph(Surv(year, dem.tax) ~ log(constmanufact) + log(constagricult) + log(urbpop) + cluster(country),
data=ag.data
)
# DO NOT TOUCH
# WORKING MODEL for clogit
clogit.1 = clogit(incometax.d ~  log(constmanufact) + log(constagricult) +strata(country), method= "efron", data = data)
#### TRY texreg PACKAGE
library(texreg) # install.packages("texreg")
texreg(
list(cox1.tt, cox2, cox.L, clogit.1, cox2.ag, logitgee.1.d),
caption = "Structural Origins of Income Taxation",
custom.coef.names = c(
"Manufacture Output$_{tt}$",
"Agricultural Output$_{tt}$",
"Manufacture Output  (ln)",
"Agricultural Output (ln)",
"Total Population  (ln)",
"Manufacture Output$_{t-1}$  (ln)",
"Agricultural Output$_{t-1}$  (ln)",
"Urban Population  (ln)",
"(intercept)"
),
custom.model.names = c(
"Cox-PH",
"Cox-PH",
"Cox-PH: Lagged",
"Conditional Logit",
"Cox-PH: Andersen-Gill",
"Logit GEE"),
label = "results:1",
custom.note = "%stars. Robust Standard Errors in All Models",
fontsize = "scriptsize",
float.pos = "h"
)
extract.geepack <- function(model) {
s <- summary(model)
names <- rownames(s$coef)
co <- s$coef[, 1]
se <- s$coef[, 2]
pval <- s$coef[, 4]
n <- nrow(model.frame(model))
nclust <- length(s$geese$clusz)
gof = c(n, nclust)
gof.names = c("Num. obs.", "Num. clust.")
tr <- createTexreg(
coef.names = names,
coef = co,
se = se,
pvalues = pval,
gof.names = gof.names,
gof = gof,
gof.decimal = rep(FALSE, length(gof))
)
return(tr)
}
logitgee.1.d = extract(logitgee.1)
logitgee.1.d = extract.geepack(logitgee.1)
logitgee.1.d
extract.geepack <- function(model) {
s <- summary(model)
names <- rownames(s$coef)
co <- s$coef[, 1]
se <- s$coef[, 2]
pval <- s$coef[, 4]
n <- nrow(model.frame(model))
nclust <- length(s$geese$clusz)
gof = c(n, nclust)
gof.names = c("Num. obs.", "Num. clust.")
tr <- createTexreg(
coef.names = names,
coef = co,
se = se,
pvalues = pval,
gof.names = gof.names,
gof = gof,
gof.decimal = rep(FALSE, length(gof))
)
return(tr)
}
logitgee.1.d = extract.geepack(logitgee.1)
texreg(
list(cox1.tt, cox2, cox.L, clogit.1, cox2.ag, logitgee.1.d),
caption = "Structural Origins of Income Taxation",
custom.coef.names = c(
"Manufacture Output$_{tt}$",
"Agricultural Output$_{tt}$",
"Manufacture Output  (ln)",
"Agricultural Output (ln)",
"Total Population  (ln)",
"Manufacture Output$_{t-1}$  (ln)",
"Agricultural Output$_{t-1}$  (ln)",
"Urban Population  (ln)",
"(intercept)"
),
custom.model.names = c(
"Cox-PH",
"Cox-PH",
"Cox-PH: Lagged",
"Conditional Logit",
"Cox-PH: Andersen-Gill",
"Logit GEE"),
label = "results:1",
custom.note = "%stars. Robust Standard Errors in All Models",
fontsize = "scriptsize",
float.pos = "h"
)
screenreg(
list(cox1.tt, cox2, cox.L, clogit.1, cox2.ag, logitgee.1.d),
caption = "Structural Origins of Income Taxation",
custom.coef.names = c(
"Manufacture Output$_{tt}$",
"Agricultural Output$_{tt}$",
"Manufacture Output  (ln)",
"Agricultural Output (ln)",
"Total Population  (ln)",
"Manufacture Output$_{t-1}$  (ln)",
"Agricultural Output$_{t-1}$  (ln)",
"Urban Population  (ln)",
"(intercept)"
),
custom.model.names = c(
"Cox-PH",
"Cox-PH",
"Cox-PH: Lagged",
"Conditional Logit",
"Cox-PH: Andersen-Gill",
"Logit GEE"),
label = "results:1",
custom.note = "%stars. Robust Standard Errors in All Models",
fontsize = "scriptsize",
float.pos = "h"
)
View(ag.data)
?texreg
# devtools::install_github('christophergandrud/simPH')
library(simPH)
library(stargazer)
# I use this one for simulation (since it seems that the sim function doesn't take well natural logs)
cox3 = coxph(Surv(year, incometax.s) ~ constmanufact + constagricult + totpop + cluster(country),
data=cox
)
library(texreg) # install.packages("texreg")
texreg(cox3,
caption = "Structural Origins of Income Taxation: Model Used to Compute Simulations",
custom.coef.names = c(
"Manufacture Output",
"Agricultural Output",
"Total Population"),
custom.model.names = "Cox-PH",
label = "results:2",
custom.note = "%stars. Robust Standard Errors in All Models",
fontsize = "scriptsize",
float.pos = "h"
)
set.seed(602)
sim3.m <- coxsimLinear(cox3,
b = "constmanufact",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constmanufact), max(cox$constmanufact), by=250)
)
set.seed(602)
sim3.a <- coxsimLinear(cox3,
b = "constagricult",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constagricult), max(cox$constagricult), by=150)
)
sim3.m <- coxsimLinear(cox3,
b = "constmanufact",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constmanufact), max(cox$constmanufact), by=250)
)
library(simPH)
devtools::install_github('christophergandrud/simPH')
library(simPH)
# I use this one for simulation (since it seems that the sim function doesn't take well natural logs)
cox3 = coxph(Surv(year, incometax.s) ~ constmanufact + constagricult + totpop + cluster(country),
data=cox
)
library(texreg) # install.packages("texreg")
texreg(cox3,
caption = "Structural Origins of Income Taxation: Model Used to Compute Simulations",
custom.coef.names = c(
"Manufacture Output",
"Agricultural Output",
"Total Population"),
custom.model.names = "Cox-PH",
label = "results:2",
custom.note = "%stars. Robust Standard Errors in All Models",
fontsize = "scriptsize",
float.pos = "h"
)
set.seed(602)
sim3.m <- coxsimLinear(cox3,
b = "constmanufact",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constmanufact), max(cox$constmanufact), by=250)
)
set.seed(602)
sim3.a <- coxsimLinear(cox3,
b = "constagricult",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constagricult), max(cox$constagricult), by=150)
)
simGG(sim3.m, xlab = "Industrial Output")
simGG(sim3.a, xlab = "Agricultural Output")
sim3.a
simPH
?simPH
set.seed(602)
sim3.m <- coxsimLinear(cox3,
b = "constmanufact",
qi = "Hazard Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constmanufact), max(cox$constmanufact), by=250)
)
set.seed(602)
sim3.a <- coxsimLinear(cox3,
b = "constagricult",
qi = "Hazard Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constagricult), max(cox$constagricult), by=150)
)
# It says "All Xl set to 0" b/c it sets the reference category to 0.
# Hazard ratios are COMPARISONS, so the coefficients mean the effects of the Betas, relative to 0.
# Plot
## IMPORTANT! A relative hazard for a unit at zero is always one, as it is a ratio of the hazards with itself. Gandrud2015 p. 10
simGG(sim3.m, xlab = "Industrial Output")
simGG(sim3.a, xlab = "Agricultural Output")
set.seed(602)
sim3.m <- coxsimLinear(cox3,
b = "constmanufact",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constmanufact), max(cox$constmanufact), by=250)
)
set.seed(602)
sim3.a <- coxsimLinear(cox3,
b = "constagricult",
qi = "Relative Hazard",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constagricult), max(cox$constagricult), by=150)
)
simGG(sim3.m, xlab = "Industrial Output")
simGG(sim3.a, xlab = "Agricultural Output")
set.seed(602)
sim3.m <- coxsimLinear(cox3,
b = "constmanufact",
qi = "Hazard Ratio",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constmanufact), max(cox$constmanufact), by=250)
)
set.seed(602)
sim3.a <- coxsimLinear(cox3,
b = "constagricult",
qi = "Hazard Ratio",
nsim = 2000,
spin = T,
Xj = seq(min(cox$constagricult), max(cox$constagricult), by=150)
)
# It says "All Xl set to 0" b/c it sets the reference category to 0.
# Hazard ratios are COMPARISONS, so the coefficients mean the effects of the Betas, relative to 0.
# Plot
## IMPORTANT! A relative hazard for a unit at zero is always one, as it is a ratio of the hazards with itself. Gandrud2015 p. 10
simGG(sim3.m, xlab = "Industrial Output")
simGG(sim3.a, xlab = "Agricultural Output")
?survfit.coxph
sim3.m$sims["QI"]
table(sim3.m$sims["QI"])
summary(sim3.m$sims["QI"])
data = sim3.m$sims["QI"]
data = data.frame(sim3.m$sims["QI"])
data.frame(sim3.m$sims["QI"])
data = head(data.frame(sim3.m$sims["QI"]))
data
survfit(cox3)
cox3
cox3.p = survfit(Surv(year, incometax.s) ~ constmanufact + constagricult + totpop + cluster(country),
data=cox
)
cox3.p
plot(cox3.p)
head(cox$incometax.s)
View(cox)
cox3.p = survfit(Surv(year, incometax.s) ~ constmanufact + constagricult + totpop,
data=cox
)
plot(cox3.p)
legend(100, .8, c("Maintained", "Nonmaintained"), lty = 2:3)
plot(survfit(fit,
newdata=data.frame(constmanufact<quantile(cox$constmanufact, .15))),
xscale=365.25,
xlab = "Years",
ylab="Survival")
plot(survfit(cox3.p,
newdata=data.frame(constmanufact<quantile(cox$constmanufact, .15))),
xscale=365.25,
xlab = "Years",
ylab="Survival")
cox$constmanufact
quantile(cox$constmanufact, .15)
plot(survfit(cox3.p,
newdata=data.frame(constmanufact=quantile(cox$constmanufact, .15))),
xscale=365.25,
xlab = "Years",
ylab="Survival")
constmanufact=quantile(cox$constmanufact, .15))
constmanufact=quantile(cox$constmanufact, .15)
constmanufact=quantile(cox$constmanufact, .15)
constmanufact
plot(survfit(cox3.p, newdata=data.frame(constmanufact=50)),
xscale=365.25,
xlab = "Years",
ylab="Survival")
plot(survfit(cox3.p, newdata=data.frame(constmanufact=50)),
xlab = "Years",
ylab="Survival")
survfit(cox3.p, newdata=data.frame(constmanufact=50))
cox3.p = survfit(Surv(year, incometax.s) ~ constmanufact + constagricult + totpop,
data=cox
)
survfit(cox3.p, newdata=data.frame(constmanufact=50))
summary(cox$constmanufact)
